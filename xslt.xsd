<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright © 2001 World Wide Web Consortium, (Massachusetts Institute of
    Technology, European Research Consortium for Informatics and Mathematics,
    Keio University). All Rights Reserved. This work is distributed under
    the W3C® Software License [1].

    [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231

    Portions © 2004-2009 Microsoft Corporation.  All rights reserved.
    This file was derived from http://www.w3.org/TR/xslt#dtd.
-->
<xs:schema targetNamespace="http://www.w3.org/1999/XSL/Transform"
           xmlns="http://www.w3.org/1999/XSL/Transform"
           xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:vs="http://schemas.microsoft.com/Visual-Studio-Intellisense"
           elementFormDefault="qualified">
  <xs:import namespace="http://www.w3.org/XML/1998/namespace" />
  <xs:complexType name="apply-imports">
    <xs:annotation>
      <xs:documentation>Invokes an overridden template rule defined in an imported style sheet.</xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:complexType name="apply-templates">
    <xs:annotation>
      <xs:documentation>Directs the XSLT processor to find the appropriate template to apply, based on the type and context of each selected node.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="sort" type="sort" />
      <xs:element name="with-param" type="with-param" />
    </xs:choice>
    <xs:attribute name="mode" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>The mode attribute allows an element as specified by its Qualified Name (QName) to be processed multiple times, each time producing a different result. If &lt;xsl:template&gt; does not have a match attribute, it cannot have a mode attribute. If an &lt;xsl:apply-templates&gt; element has a mode attribute, it applies only to template rules from &lt;xsl:template&gt; elements that have a mode attribute with the same value. If an &lt;xsl:apply-templates&gt; element does not have a mode attribute, it applies only to template rules from &lt;xsl:template&gt; elements that do not have a mode attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="select" type="xs:string" default="node()">
      <xs:annotation>
        <xs:documentation>Can be used to process nodes selected by an expression, instead of processing all children. The value of the select attribute is an expression, which must evaluate to a node-set. The selected node-set is processed in document order, unless a different sort order has been specified.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="char-instructions">
    <xs:choice>
      <xs:element name="apply-templates" type="apply-templates" />
      <xs:element name="call-template" type="call-template" />
      <xs:element name="apply-imports" type="apply-imports" />
      <xs:element name="for-each" type="for-each" />
      <xs:element name="value-of" type="value-of" />
      <xs:element name="copy-of" type="copy-of" />
      <xs:element name="number" type="number" />
      <xs:element name="choose" type="choose" />
      <xs:element name="if" type="if" />
      <xs:element name="text" type="text" />
      <xs:element name="copy" type="copy" />
      <xs:element name="variable" type="variable" />
      <xs:element name="message" type="message" />
      <xs:element name="fallback" type="fallback" />
      <xs:any namespace="##other" processContents="lax" />
    </xs:choice>
  </xs:group>
  <xs:group name="instructions">
    <xs:choice>
      <xs:group ref="char-instructions" />
      <xs:element name="processing-instruction" type="processing-instruction" />
      <xs:element name="comment" type="comment" />
      <xs:element name="element" type="element" />
      <xs:element name="attribute" type="attribute" />
    </xs:choice>
  </xs:group>
  <xs:group name="top-level">
    <xs:sequence>
      <xs:element name="import" type="import" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="include" type="include" />
        <xs:element name="strip-space" type="strip-space" />
        <xs:element name="preserve-space" type="preserve-space" />
        <xs:element name="output" type="output" />
        <xs:element name="key" type="key" />
        <xs:element name="decimal-format" type="decimal-format" />
        <xs:element name="attribute-set" type="attribute-set" />
        <xs:element name="variable" type="variable" />
        <xs:element name="param" type="param" />
        <xs:element name="template" type="template" />
        <xs:element name="namespace-alias" type="namespace-alias" />
        <xs:any namespace="##other" processContents="lax" />
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="attribute" mixed="true">
    <xs:annotation>
      <xs:documentation>Creates an attribute node and attaches it to an output element.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="char-instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The name of the attribute to create. If this value is a qualified name (QName), the attribute node is created in the namespace currently bound to the prefix, unless it is overridden by a namespace attribute. The value of the name attribute is interpreted as an attribute value template (expressions in curly braces are evaluated and converted to strings as in the &lt;xsl:value-of&gt; element). This allows the name of the attribute to be calculated or obtained from the source XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace Uniform Resource Identifier (URI) of the created attribute. If the name attribute contains a QName, the prefix specified there will be bound to the namespace specified in the namespace attribute. This might result in the addition of other namespace declarations when serializing. This value is interpreted as an attribute value template.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="attribute-set">
    <xs:annotation>
      <xs:documentation>Defines a named set of attributes.</xs:documentation>
    </xs:annotation>
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="attribute" type="attribute" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. The Qualified Name (QName) of the attribute set. The value of the name attribute is a qualified name.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="use-attribute-sets" type="xs:NMTOKENS">
      <xs:annotation>
        <xs:documentation>A white space-separated list of attribute sets, specified as a Qualified Name (QName). Specifying this attribute declares each attribute in each listed attribute set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="call-template">
    <xs:annotation>
      <xs:documentation>Invokes a template by name.</xs:documentation>
    </xs:annotation>
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="with-param" type="with-param" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. The Qualified Name (QName) name of the template to be invoked.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="choose">
    <xs:annotation>
      <xs:documentation>Tests multiple conditions in conjunction with the &lt;xsl:otherwise&gt; and &lt;xsl:when&gt; elements.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="when" type="when" />
      <xs:element minOccurs="0" maxOccurs="1" name="otherwise" type="otherwise" />
    </xs:sequence>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="comment" mixed="true">
    <xs:annotation>
      <xs:documentation>Generates a comment in the output.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="char-instructions" />
    </xs:choice>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="copy" mixed="true">
    <xs:annotation>
      <xs:documentation>Copies the current node from the source to the output.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="use-attribute-sets" type="xs:NMTOKENS">
      <xs:annotation>
        <xs:documentation>A white space separated list of attribute sets, specified as a list of Qualified Names (QNames). Specifying this attribute declares each attribute in each listed attribute set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="copy-of">
    <xs:annotation>
      <xs:documentation>Inserts subtrees and result tree fragments into the result tree.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="select" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. XPath expression identifying nodes to be copied. The subtree below each of these nodes is copied to the result tree in its entirety.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="decimal-format">
    <xs:annotation>
      <xs:documentation>Declares a decimal-format, which controls the interpretation of a format pattern used by the format-number function. If there is a name attribute, the element declares a named decimal-format; otherwise, it declares the default decimal-format. The value of the name attribute is a Qualified Name (QName). An error occurs if you declare either the default decimal-format or a decimal-format with a given name more than once (even with different import precedence), unless it is declared every time with the same value for all attributes (taking into account any default values). </xs:documentation>
    </xs:annotation>
    <xs:attribute default="." name="decimal-separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used to separate the integer and the fraction part of a number. The default is ".".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="#" name="digit" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used in a format pattern to indicate a place where a leading zero digit is required. The default value is "#".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="," name="grouping-separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used to separate groups of digits. The default is ",".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="Infinity" name="infinity" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The string used to represent infinity; the default value is the string "Infinity".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="-" name="minus-sign" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used as the default minus sign; the default value is the hyphen-minus character ("-", "#x2D").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>Optional. The Qualified Name (QName) of the decimal-format. If there is a name attribute, the element declares a named decimal-format; otherwise, it declares the default decimal-format. The value of the name attribute is a qualified name. It is an error to declare either the default decimal-format or a decimal-format with a given name more than once unless it is declared every time with the same value for all attributes (taking into account any default values).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="NaN" name="NaN" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The string used to represent the NaN value; the default value is the string "NaN".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default=";" name="pattern-separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used to separate positive and negative sub patterns in a pattern. The default value is the semi-colon character (";"). An example of the semi-colon used in a pattern is the following:format-number(-123.45, '###,###.00;(###,###.00)')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="%" name="percent" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used as a percent sign; the default value is the percent character ("%").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="‰" name="per-mille" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used as a per mille (per thousand) sign; the default value is the Unicode per-mille character ("#x2030").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="0" name="zero-digit" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional. The character used as the digit zero; the default value is the digit zero ("0").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="element" mixed="true">
    <xs:annotation>
      <xs:documentation>Creates an output element with the specified name.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The name of the element to create. If this value is a Qualified Name (QName), the element node is created in the namespace currently bound to the prefix, unless overridden by a namespace attribute. The value of the name attribute is interpreted as an attribute value template — that is, expressions in curly braces are evaluated and converted to strings, as in &lt;xsl:value-of&gt;. This allows the name of the element to be calculated or obtained from the source XML.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace URI of the created element. If the name attribute contains a QName, the prefix specified there will be bound to the namespace specified in the namespace attribute. This might require additional namespace declarations when serializing. The namespace value is interpreted as an attribute value template.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="use-attribute-sets" type="xs:NMTOKENS">
      <xs:annotation>
        <xs:documentation>A white space separated list of attribute sets, specified as a Qualified Name (QName). Specifying this attribute declares each attribute in each listed attribute set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="fallback" mixed="true">
    <xs:annotation>
      <xs:documentation>The &lt;xsl:fallback&gt; element is designed to handle XSLT elements that cannot be handled by the parser: for example, elements that are part of a new version or unrecognized extension. The &lt;xsl:fallback&gt; element works by calling template content that provides a reasonable substitute for the behavior of the new element.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="for-each" mixed="true">
    <xs:annotation>
      <xs:documentation>Applies a template repeatedly — that is, to each node in a set.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="sort" type="sort" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="instructions" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="select" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. Expression evaluated on the current context to determine the set of nodes to iterate over.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="if" mixed="true">
    <xs:annotation>
      <xs:documentation>Allows simple conditional template fragments.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="test" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The condition in the source data to test. If the expression in this attribute evaluates to True when cast to a Boolean, the content of &lt;xsl:if&gt; is instantiated and placed in the output. Node-sets are cast to a Boolean True if they contain at least one node.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="import">
    <xs:annotation>
      <xs:documentation>Imports another XSLT file.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="href" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. A Uniform Resource Identifier (URI) reference that identifies the XSLT file to be imported.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="include">
    <xs:annotation>
      <xs:documentation>Includes another XSLT file.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="href" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. A Uniform Resource Identifier (URI) reference identifying the XSLT file to be included.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="key">
    <xs:annotation>
      <xs:documentation>The &lt;xsl:key&gt; element declares a named key — that is, a name-value pair assigned to a specified element in an XML document. The key is used with the key() function in XPath expressions to help you access the assigned elements in a complex XML document efficiently.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="match" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Specifies the pattern that identifies a node that holds this key. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Specifies the Qualified Name (QName) of the key. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="use" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Specifies an expression to be used as the value of the key. The key value can be one of the following: an attribute, a child element, or the content of the matched element.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="message" mixed="true">
    <xs:annotation>
      <xs:documentation>The &lt;xsl:message&gt; element sends a text message to either the message buffer or a message dialog box, depending on the environment in which the element call is made. It also raises a system-level error message that can be trapped through normal error-handling mechanisms.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute default="no" name="terminate">
      <xs:annotation>
        <xs:documentation>Specifies whether the transformation should terminate upon executing this instruction. This attribute can have one of two string values: "yes" or "no". When the terminate attribute is set to "yes", the content of the element is displayed as the part of the system-level error message, and the transformation terminates. When it is set to "no", the transformation proceeds, ignoring the error message. The default value is "no". </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="yes" />
          <xs:enumeration value="no" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="namespace-alias">
    <xs:annotation>
      <xs:documentation>The &lt;xsl:namespace-alias&gt; element replaces the prefix associated with a given namespace with another prefix.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="result-prefix" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The prefix for the namespace URI used in the result tree.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stylesheet-prefix" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The prefix for the namespace URI used in the XSLT file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="number">
    <xs:annotation>
      <xs:documentation>Inserts a formatted number into the result tree.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="count" type="xs:string">
      <xs:annotation>
        <xs:documentation>A pattern that specifies what nodes should be counted at those levels. If the count attribute is not specified, then it defaults to the pattern that matches any node with the same node type as the current node and, if the current node has an expanded-name, with the same expanded-name as the current node.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="1" name="format" type="xs:string">
      <xs:annotation>
        <xs:documentation>A sequence of tokens that specifies the format to be used for each number in the list. If there are no format tokens, then the default value of 1 is used which generates a sequence 1 2 ... 10 11 12.... Each number after the first is separated from the preceding number by the separator token preceding the format token used to format that number. If there are no separator tokens, a period character is used (".").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from" type="xs:string">
      <xs:annotation>
        <xs:documentation>A pattern that specifies where counting starts.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="grouping-separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences. For example, grouping-separator="," and grouping-size="3" would produce numbers of the form 1,000,000. If only one of the grouping-separator and grouping-size attributes is specified, it is ignored.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="grouping-size" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specifies the size (normally 3) of the grouping. For example, grouping-separator="," and grouping-size="3" would produce numbers of the form 1,000,000. If only one of the grouping-separator and grouping-size attributes is specified, it is ignored.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lang">
      <xs:annotation>
        <xs:documentation>Specifies which language's alphabet is used. If no lang value is specified, the language is determined from the system environment.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="letter-value">
      <xs:annotation>
        <xs:documentation>Disambiguates between numbering sequences that use letters. One numbering sequence assigns numeric values to letters in alphabetic sequence, and the other assigns numeric values to each letter in some other manner traditional in that language. In English, these correspond to the numbering sequences specified by the format tokens "a" and "i". In some languages, the first member of each sequence is the same, and so the format token alone would be ambiguous. A value of "alphabetic" specifies the alphabetic sequence; a value of "traditional" specifies the other sequence. Default is "alphabetic".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute default="single" name="level">
      <xs:annotation>
        <xs:documentation>Specifies what levels of the source tree should be considered; it has the values "single", "multiple" and "any". The default is "single".</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="single" />
          <xs:enumeration value="multiple" />
          <xs:enumeration value="any" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specifies the expression to be converted to a number and output to the result tree. If no value attribute is specified, the &lt;xsl:number&gt; element inserts a number based on the position of the current node in the source tree.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="otherwise" mixed="true">
    <xs:annotation>
      <xs:documentation>Provides multiple conditional testing in conjunction with the &lt;xsl:choose&gt; and &lt;xsl:when&gt; elements.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="output">
    <xs:annotation>
      <xs:documentation>Specifies options for use in serializing the result tree.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="cdata-section-elements" type="xs:NMTOKENS">
      <xs:annotation>
        <xs:documentation>Specifies a list of the Qualified Names (QNames) of elements whose text node children should be output using CDATA sections.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="doctype-public" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specifies the public identifier to be used in the DTD.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="doctype-system" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specifies the system identifier to be used in the DTD.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encoding" type="encoding">
      <xs:annotation>
        <xs:documentation>Specifies the preferred character encoding that the parser should use to encode sequences of characters as sequences of bytes. The value of the attribute is treated case-insensitively; it must contain only printable ASCII characters and be a registered character set, or begin with x-.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indent">
      <xs:annotation>
        <xs:documentation>Specifies additional white space to add when outputting the result tree; the value must be yes or no.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="yes" />
          <xs:enumeration value="no" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="media-type" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specifies the media type (MIME content type) of the data that results from outputting the result tree.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method">
      <xs:annotation>
        <xs:documentation>Identifies the overall method used for outputting the result tree. If there is no prefix, it identifies a method specified in this document that must be one of "xml", "html", "text", or a qualified name (QName) that is not an NCName). If there is a prefix, it is expanded and identifies the output method.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN" />
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:enumeration value="html" />
              <xs:enumeration value="text" />
              <xs:enumeration value="xml" />
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="omit-xml-declaration">
      <xs:annotation>
        <xs:documentation>Specifies whether the XSLT processor should output an XML declaration; the value must be yes or no.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="yes" />
          <xs:enumeration value="no" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="standalone">
      <xs:annotation>
        <xs:documentation>Specifies whether the XSLT processor should output a standalone document declaration; the value must be yes or no.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="yes" />
          <xs:enumeration value="no" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="version" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>Specifies version 1.0 in relation to the "xml" output method; this appears in the output XML declaration as &lt;?xml version="1.0"?&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="param" mixed="true">
    <xs:annotation>
      <xs:documentation>Declares a named parameter for use within an &lt;xsl:stylesheet&gt; element or an &lt;xsl:template&gt; element. Allows specification of a default value.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. Specifies the Qualified Name (QName) of the parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="select" type="xs:string">
      <xs:annotation>
        <xs:documentation>The value of the attribute is an expression, and the value of the variable is the object that results from evaluating the expression. When this attribute is specified, the &lt;xsl:param&gt; element must be empty.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="preserve-space">
    <xs:annotation>
      <xs:documentation>Preserves white space only text nodes that may appear in those elements as specified by the elements attribute. </xs:documentation>
    </xs:annotation>
    <xs:attribute name="elements" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>This is a required attribute. The value is a white space separated list of name tokens of the nodes whose white space only text nodes must be preserved. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="processing-instruction" mixed="true">
    <xs:annotation>
      <xs:documentation>Generates a processing instruction node in the output.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="char-instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The NCName of the processing instruction.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="sort">
    <xs:annotation>
      <xs:documentation>Specifies sort criteria for node lists selected by &lt;xsl:for-each&gt; or &lt;xsl:apply-templates&gt;.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="select" type="xs:string" default=".">
      <xs:annotation>
        <xs:documentation>The sort key for the node. An expression that is evaluated with the specified node as the current node, and with the complete list of nodes being processed in unsorted order as the current node-list. The resulting object is converted to a string that is used as the sort key for that node. The default value of the select attribute is ".". This causes the string-value of the current node to be used as the sort key.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lang">
      <xs:annotation>
        <xs:documentation>The language alphabet used to determine sort order. If no lang value is specified, the language is determined from the system environment.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="data-type" default="text">
      <xs:annotation>
        <xs:documentation>The data type of the strings. The following table list the values allowed for the data-type attribute. </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:enumeration value="text" />
              <xs:enumeration value="number" />
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:string" />
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="order" default="ascending">
      <xs:annotation>
        <xs:documentation>The sort order for the strings. The default value is "ascending".</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:enumeration value="ascending" />
              <xs:enumeration value="descending" />
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:string" />
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="case-order">
      <xs:annotation>
        <xs:documentation>The order in which to sort strings by capitalization. The default value is "upper-first", which sorts the strings with uppercase letter first.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:enumeration value="lower-first" />
              <xs:enumeration value="upper-first" />
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:string" />
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="strip-space">
    <xs:annotation>
      <xs:documentation>Strips white-space-only text nodes that might appear in elements specified by the elements attributes.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="elements" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The value of this required attribute is a white-space-separated list of name tokens of the nodes whose white-space-only text nodes should be stripped.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:element name="stylesheet" type="transform" />
  <xs:element name="transform" type="transform" />
  <xs:complexType name="template" mixed="true">
    <xs:annotation>
      <xs:documentation>Defines a reusable template for generating the desired output for nodes of a particular type and context.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="param" type="param" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="instructions" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="match" type="xs:string">
      <xs:annotation>
        <xs:documentation>A pattern that identifies the source node or nodes to which the rule applies. The match attribute is required unless the &lt;xsl:template&gt; element has a name attribute. The content of the &lt;xsl:template&gt; element is the template that is instantiated when the template rule is applied.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>The mode value. This value allows an element to be processed multiple times, each time producing a different result. If &lt;xsl:template&gt; does not have a match attribute, it must not have a mode attribute. If an &lt;xsl:apply-templates&gt; element has a mode attribute, it applies only to those template rules from &lt;xsl:template&gt; elements that have a mode attribute with the same value; if an &lt;xsl:apply-templates&gt; element does not have a mode attribute, it applies only to those template rules from &lt;xsl:template&gt; elements that do not have a mode attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>The Qualified Name (QName) to be expanded. If it has a prefix, the prefix is expanded into a Uniform Resource Identifier (URI) reference using the namespace declarations in effect on the attribute in which the name occurs. The expanded-name, consisting of the local part of the name and the possibly null URI reference is used as the name of the template. The default namespace is not used for unprefixed names. If an &lt;xsl:template&gt; element has a name attribute, it can, but need not, also have a match attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>The priority number for the template. All matching template rules that have lower priority than the matching template rule or rules with the highest priority are eliminated from consideration. The value of this must be a real number from 0–9, positive or negative, matching the production number with an optional leading minus sign (-). The default priority is computed as follows:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="text">
    <xs:annotation>
      <xs:documentation>Generates text node from a style sheet. White-space-only nodes are preserved in the output.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute default="no" name="disable-output-escaping">
          <xs:annotation>
            <xs:documentation>Default is "no". If the value is "yes", a text node generated by instantiating the &lt;xsl:text&gt; element will be output without any escaping. For example, the following generates the single character "&lt;".  </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:enumeration value="yes" />
              <xs:enumeration value="no" />
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute ref="xml:space" />
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="transform">
    <xs:annotation>
      <xs:documentation>Specifies the document element of an XSLT file. The document element contains all other XSLT elements.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="top-level" />
    </xs:sequence>
    <xs:attribute name="exclude-result-prefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace URI to be used as an excluded namespace. The value is a white-space-separated list of namespace prefixes. The namespace bound to each of the prefixes is designated as an excluded namespace. The default namespace (as declared by xmlns) may be designated as an excluded namespace by including #default in the list of namespace prefixes. The designation of a namespace as an excluded namespace is effective within the subtree of the style sheet rooted at the element bearing the exclude-result-prefixes; a subtree rooted at an &lt;xsl:stylesheet&gt; element does not include any style sheets imported or included by children of that &lt;xsl:stylesheet&gt; element.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extension-element-prefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace to be used as an extension namespace. The value is a white-space-separated list of namespace prefixes. The namespace bound to each of the prefixes is designated as an extension namespace. The default namespace (as declared by xmlns) can be designated as an extension namespace by including #default in the list of namespace prefixes. The designation of a namespace as an extension namespace is effective within the subtree of the style sheet rooted at the element bearing the extension-element-prefixes; a subtree rooted at an &lt;xsl:stylesheet&gt; element does not include any style sheets imported or included by children of that &lt;xsl:stylesheet&gt; element.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="id" type="xs:ID">
      <xs:annotation>
        <xs:documentation>A unique identifier that facilitates embedding style sheets.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. The version of XSLT that the XSLT file requires. The value should be set to "1.0" for this version of XSLT.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="value-of">
    <xs:annotation>
      <xs:documentation>Inserts the value of the selected node as text.</xs:documentation>
    </xs:annotation>
    <xs:attribute default="no" name="disable-output-escaping">
      <xs:annotation>
        <xs:documentation>Default is "no". If the value is "yes", a text node generated by instantiating the &lt;xsl:value-of&gt; element will be output without any escaping. For example, the following generates the single character "&lt;".  </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="yes" />
          <xs:enumeration value="no" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="select" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The expression to be evaluated against the current context. The results are converted to a string, as by a call to the string() function. A node-set is converted to a string by inserting the string value of the first node in the set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="variable" mixed="true">
    <xs:annotation>
      <xs:documentation>Specifies a value bound in an expression.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. The Qualified Name (QName) of the variable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="select" type="xs:string">
      <xs:annotation>
        <xs:documentation>The value of the attribute is an expression, and the value of the variable is the object that results from evaluating the expression. When this attribute is specified, the content of &lt;xsl:variable&gt; must be empty.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="when" mixed="true">
    <xs:annotation>
      <xs:documentation>Provides multiple conditional testing in conjunction with the &lt;xsl:choose&gt; and &lt;xsl:otherwise&gt; elements.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="test" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Required. The condition in the source data to test. If the expression in this attribute evaluates to True when cast to a Boolean, the content of &lt;xsl:when&gt; is instantiated and placed in the output. Node-sets are cast to a Boolean True if they contain at least one node.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:complexType name="with-param" mixed="true">
    <xs:annotation>
      <xs:documentation>Passes a parameter to a template.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="instructions" />
    </xs:choice>
    <xs:attribute name="name" type="xs:NMTOKEN" use="required">
      <xs:annotation>
        <xs:documentation>Required. The Qualified Name (QName) of the parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="select" type="xs:string">
      <xs:annotation>
        <xs:documentation>An expression to be matched against the current context. There is no default value. An empty string is generated if there is no content.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="xml:space" />
  </xs:complexType>
  <xs:simpleType name="encoding" vs:builder="encoding">
    <xs:restriction base="xs:string" />
  </xs:simpleType>
  <!-- global attributes for literal result elements -->
  <xs:attribute name="exclude-result-prefixes" type="xs:string" />
  <xs:attribute name="extension-element-prefixes" type="xs:string" />
  <xs:attribute name="use-attribute-sets" type="xs:NMTOKENS" />
  <xs:attribute name="version" type="xs:string" />
</xs:schema>
